# -*- coding: utf-8 -*-
"""My_twitter_SNA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bxypXUaZR5IkuL1kwVdXAA3HqTFP2Z9o
"""

pip install surprise

import pandas as pd
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
from collections import defaultdict 
import surprise
from surprise.reader import Reader
from surprise import Dataset
from surprise.model_selection import GridSearchCV
from surprise.model_selection import cross_validate
from surprise import SVD
from surprise import NMF
from scipy.spatial.distance import hamming
np.random.seed(42)

from google.colab import drive
drive.mount('/content/drive')

!tar -xzvf "/content/drive/MyDrive/twitter.tar.gz" -C "/content/drive/MyDrive/twitter_data/"  #one time run



"""## Collaborative filttering script (user-based approach)"""

def get_node_ids(folder_path):

  ''' return list of all node ids available in folder '''

  node_id_set = set()
  for fname in os.listdir(folder_path):
    if 'edges' in fname:
      nodeid = fname.split('.')[0]
      node_id_set.add(nodeid)
  return node_id_set

def fetch_data(folder_path,node_ids):

  '''fetch data from folder_path and store it in one single dataframe'''

  for ind, node in enumerate(node_ids):
    final_file_path = folder_path+node+'.edges'
    
    df_temp = pd.read_csv(final_file_path,sep=' ',names=['ucol1','ucol2'])
    
    if ind == 0:
      df_final = df_temp.copy()

    else:
      df_final = df_final.append(df_temp)
  
  df_final['label'] = 1.0
 
  return df_final

# function call
Node_lst = ['170729553']
folder_path = '/content/drive/MyDrive/twitter_data/twitter/'

# getting all node ids
node_lst = list(get_node_ids(folder_path))[:30]   #selecting first 30 ego nodes
node_lst.append(Node_lst[0])  #Node_lst contains node for which CBR is Build

# preparing final dataframe
df_final = fetch_data(folder_path,node_lst)

print("In total for {} users the recommendation system will be build".format(len(set(df_final['ucol1']))))

def get_user_user_matrix(df_user_user):

  ''' convert pandas dataframe into user-user matrix '''

  user_user_mat = df_user_user.pivot_table(index='ucol1',columns='ucol2',values='label',fill_value=0)
  user_user_mat['user_id'] = user_user_mat.index
  usr_col = user_user_mat['user_id']
  user_user_mat = user_user_mat.drop(columns=['user_id'])
  user_user_mat.insert(loc=0,column='user_id',value=usr_col)
  user_user_mat.reset_index(drop=True, inplace=True)
  return user_user_mat

user_user_mat = get_user_user_matrix(df_final)

user_user_mat.head(2)

from scipy.spatial.distance import hamming

def collaborative_filtering(user_id: int,num_recommedations: int, uu_mat):
  
  user_dist_dict = {}
  user_id_vec = uu_mat[uu_mat['user_id']==user_id].iloc[:,1:].values
  for uid in uu_mat['user_id']:

    if user_id != uid:

      user_vec = uu_mat[uu_mat['user_id']==uid].iloc[:,1:].values

      hamming_dist = hamming(user_id_vec,user_vec)

      user_dist_dict[uid] = hamming_dist

      sorted_user_dist_dict = sorted(user_dist_dict.items(),key=lambda x:x[1])
  
  for ind,pair in enumerate(sorted_user_dist_dict):
    usr_id = pair[0]
    user_id_df = uu_mat[uu_mat['user_id']==user_id]
    user_df = uu_mat[uu_mat['user_id']==usr_id]
    final_df = user_id_df.append(user_df)

    diff_df = final_df.diff(axis = 0, periods = 1)
    diff_df_fil = diff_df.iloc[:,1:]
    rec_users = set(diff_df_fil.apply(lambda row: row[row == 1].index, axis=1)[1])

    if ind == 0:
      final_rec_users = rec_users

    else:

      final_rec_users = final_rec_users.union(rec_users)

  lst_rec_users = list(final_rec_users)
  
  return lst_rec_users[:num_recommedations], diff_df_fil


recs = collaborative_filtering(12,10,user_user_mat)

df_feat.head(2)

"""## Data Preparation for Content Based Reecommendations"""

def get_feature_names(path,Node_lst):

  ''' get feature names from node.featnames file '''

  final_path = path + Node_lst[0] + '.featnames'
  df_feat_names = pd.read_csv(final_path,sep=' ',names=['ind','feature'])
  feat_names_lst = list(df_feat_names['feature'])
  feat_names_lst.insert(0,'user_id')

  return feat_names_lst


def data_prep_for_CBR(Node_lst,feat_lst,folder_path):

  '''prepare dataframe form text file(.feat)'''

  for ind, node in enumerate(Node_lst):

    final_path = folder_path + node + '.feat'

    df_feat_temp = pd.read_csv(final_path,sep=' ',names=feat_lst,index_col=False)

    if ind == 0:

      df_feat_final = df_feat_temp.copy()

    else:

      df_feat_final = df_feat_final.append(df_feat_temp)

  return df_feat_final

# function calls
Node_lst = ['170729553']  # can select one ego node for CBR since all ego_networks has different set of features

feature_names_lst = get_feature_names('/content/drive/MyDrive/twitter_data/twitter/',Node_lst)

df_cbr = data_prep_for_CBR(Node_lst,feature_names_lst,folder_path)

df_cbr.head(2)

def CBR(user_id: int,num_recommedations: int, df_cbr):

  rec_list = []
  user_dist_dict = {}
  user_id_vec = df_cbr[df_cbr['user_id']==user_id].iloc[:,1:].values
  for uid in df_cbr['user_id']:

    if user_id != uid:

      user_vec = df_cbr[df_cbr['user_id']==uid].iloc[:,1:].values

      hamming_dist = hamming(user_id_vec,user_vec)

      user_dist_dict[uid] = hamming_dist

      sorted_user_dist_dict = sorted(user_dist_dict.items(),key=lambda x:x[1])
  
  fil_dict = sorted_user_dist_dict[:num_recommedations] 

  for tup in fil_dict:
    rec_list.append(tup[0])

  return rec_list

def get_plot_df(user_id,num_recomm):

  df_plot = pd.DataFrame()
  user_lst = []
  user_lst.append(user_id)
  df_plot['Source'] = user_lst*num_recomm

  df_plot['Target'] = CBR(user_id,num_recomm, df_cbr)
  df_plot['Type'] = 'Directed'
  df_plot['weight'] = 1

  return df_plot

#execution block

user_id = int(input('Enter user id: '))
num_recomm = int(input('How Many recommendation do you want: '))

df_plot_final = get_plot_df(user_id,num_recomm)

import networkx as nx
g = nx.from_pandas_edgelist(df_plot_final,source='Source',target='Target')

import matplotlib.pyplot as plt

plt.figure(figsize=(10,8))

nx.draw(g, pos = nx.nx_pydot.graphviz_layout(g), \
    node_size=300, node_color='lightblue', linewidths=1.5, \
    font_size=11, font_weight='bold', with_labels=True)

